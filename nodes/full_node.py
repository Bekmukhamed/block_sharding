"""
To-Do:
1. Add reputation and necessary code for the Proof-of-Stake
"""

import numpy as np

from nodes.participating_node import ParticipatingNode
from network.broadcast import broadcast
from network.mini_block import MiniBlock
from network.tx_block import TxBlock
from network.pipe import Pipe
from transaction_factory.transaction import Transaction
from transaction_factory.transaction_pool import TransactionPool
from utils import get_transaction_delay


class FullNode(ParticipatingNode):
    """
    This class models the nodes which will take part in the Blockchain.
    These nodes are the subsets of the participating nodes.
    """

    def __init__(self, id, env, location, params):
        super().__init__(id, env, location, params)

        self.node_type = 0
        # 0 - Node is in between re-configuration (slot)
        # 1 - Principal Committee
        # 2 - Shard Leader
        # 3 - Shard Member
        
        self.shard_id = -1
        self.shard_leader = None
        self.curr_shard_nodes = {}
        self.neighbours_ids = []


    def add_network_parameters(self, curr_shard_nodes, neighbours_ids):
        self.curr_shard_nodes = curr_shard_nodes
        self.neighbours_ids = neighbours_ids
        self.transaction_pool = TransactionPool(
            self.env, self.id, neighbours_ids, curr_shard_nodes, self.params
        )
        self.pipes = Pipe(self.env, self.id, self.curr_shard_nodes)
        self.env.process(self.receive_block())
    

    def generate_transactions(self):
        """
        Generates transactions in the shard and broadcasts it to the neighbour nodes
        """

        # To-Do: Don't allow generation of transactions during shard re-configuration

        if self.node_type != 3:
            raise RuntimeError("Node not allowed to generate transactions.")

        num = 0
        while True:
            delay = get_transaction_delay(
                self.params["transaction_mu"], self.params["transaction_sigma"]
            )
            yield self.env.timeout(delay)
            
            value = np.random.randint(self.params["tx_value_low"], self.params["tx_value_high"])
            reward = value * self.params["reward_percentage"]

            transaction_state = {}
            for key, value in self.curr_shard_nodes.items():
                transaction_state[key] = 0

            transaction = Transaction("T_%s_%d" % (self.id, num), self.env.now, value, reward, transaction_state)
            # self.data["numTransactions"] += 1
            
            if self.params["verbose"]:
                print(
                    "%7.4f" % self.env.now
                    + " : "
                    + "%s added with reward %.2f"
                    % (transaction.id, transaction.reward)
                )

            # [WIP]: Rough Broadcast to all the neighbors
            broadcast(
                self.env, 
                transaction, 
                "Tx", 
                self.id, 
                self.neighbours_ids, 
                self.curr_shard_nodes, 
                self.params
            )

            num += 1

    
    def preprocess_transactions(self):
        """
        Pre-processes the transactions (done by shard leader)
        """
        if self.node_type != 2:
            raise RuntimeError("Pre-processing can only be performed by the shard leader")

        while True:
            delay = get_transaction_delay(
                self.params["transaction_mu"], self.params["transaction_sigma"]
            )
            yield self.env.timeout(delay)

            if self.transaction_pool.transaction_queue.length() >= self.params["mini_block_capacity"]:
                transactions_list = self.transaction_pool.transaction_queue.pop(self.params["mini_block_capacity"])

                # To-do: Add pre-processing step
                delay = get_transaction_delay(
                    self.params["transaction_mu"], self.params["transaction_sigma"]
                )
                yield self.env.timeout(delay)

                shard_neigbours = []
                for id in self.neighbours_ids:
                    if self.curr_shard_nodes[id].node_type == 3:
                        shard_neigbours.append(id)
                
                tx_block = TxBlock(f"TB_{self.id}", transactions_list, self.params, self.curr_shard_nodes)
                broadcast(
                    self.env, 
                    tx_block, 
                    "Tx-block", 
                    self.id, 
                    shard_neigbours, 
                    self.curr_shard_nodes, 
                    self.params
                )


    def generate_mini_block(self, transactions_list):
        """
        Generate a mini block and broadcast it to the shard nodes
        """
        if self.node_type != 2:
            raise RuntimeError("Mini-block can only be generated by the shard leader")

        mini_block = MiniBlock(f"MB_{self.id}", transactions_list, self.params, self.shard_id)

        principal_committee_neigbours = []
        for id in neighbours_list:
            if self.curr_shard_nodes[id].node_type == 1:
                principal_committee_neigbours.append(id)

        broadcast(
            self.env, 
            mini_block,
            "Mini-block", 
            self.id, 
            principal_committee_neigbours, 
            self.curr_shard_nodes, 
            self.params
        )


    def generate_block(self):
        """
        Generate a block and broadcast it in the entire network
        """
        if self.node_type != 1:
            raise RuntimeError("Block can only be generated by the Principal Committee")


    def cast_vote(self):
        pass

    def validate_transactions(self):
        pass

    def receive_block(self):
        """
        Receive Tx-block sent by the shard leader, or
        (final) Block sent by the Principal Committee
        """
        while True:
            b = yield self.pipes.get()

            if self.params["verbose"]:
                print(
                    "%7.4f" % self.env.now
                    + " : "
                    + "%s received a %s-block"
                    % (self.id, b.id[:2])
                )

    def update_blockchain(self):
        pass